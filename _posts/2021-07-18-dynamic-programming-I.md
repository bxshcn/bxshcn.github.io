---
layout: post
title:  "动态规划原理-以Leetcode309为例"
comments: true
categories: 算法
---
## 题设 
[Leetcode 309](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## 解题思路
动态规划的核心是状态转移方程（或者称状态转移表，或者称递推公式），而找到状态转移方程的关键有两点：
1. 定义属性及其状态值。一般来说，一个动态规划问题至少包括两个属性：一是阶段，因为动态规划就是多阶段求值过程；二是最优解对象的取值，因为动态规划是求最优解的过程。随着阶段的演进，系统的相关属性（包括最优解相关对象）的取值也会发生变化。
2. 定义状态转移方程或公式。明确属性及其状态取值后，就要厘清当前状态可以从哪些先前的状态转移过来。注意两点：
  - 同一问题往往有不同的状态定义，**简单清晰的状态定义是状态转移方程推导的关键**
  - 定义状态转移方程关注的是入度问题，即分析可以从先前的哪些状态（往往是**多个状态**）转移到当前**一个状态**；而不是出度问题，即分析可以从当前的状态，转移到哪些后续状态。出度的分析是没有意义的，因为我们只能从已知的先前阶段的多个状态下的最优解推导得到当前状态下的最优解，而不是根据当前一个状态下的最优解得到下一个阶段多个状态下的最优解，实际上，我们根本就不能从当前一个状态下的最优解推导得到下一阶段任意状态的最优解。注意，状态转移方程的映射关系总是多映射为1，而不是从1映射为多，甚至从1映射到1往往也是不可能的。

综上所述，动态规划设计时，属性及其相关状态取值的定义首当其冲。定义清楚了属性及其状态，再酌情考虑缩减状态定义，并据此优化状态转移方程。

本题的属性定义，首先是阶段，其次是收益，再其次是当天是否持有股票，以及当天是否出售过股票。这样来看，我们需要一个三维数组来表示状态：
1. 第一维是阶段
2. 第二维是是否持有股票
3. 第三维是是否出售过股票

数组的值就是收益，我们考察的就是这个收益的最大值（最优解）

如前所述，状态太多会复杂化状态转移方程的推导，因此考虑压缩状态。实际上，对于大多数“是否”即只有两个选项（或者少数几个选项）状态的维度，可以以组合策略进行合并，2和3两个维度属性取值可以组成一维的4个状态值，即：
1. 当天结束时持有股票，且当天没有卖出过股票
2. 当天结束时持有股票，且当天卖出过股票
3. 当天结束时没有股票，且当天没有卖出过股票
4. 当天结束时没有股票，且当天卖出过股票

显然，因为冻结期的存在，“当天结束时持有股票，且当天卖出过股票”是不可能的，因此真正有意义的只有1、3、4三种状态。我们可以定义一个二维数组states[i][3]，其中i表示阶段，3表示这里所述的三个有效状态，数组的元素表示收益。

另外，很多情况下，当前阶段的状态只与上一个阶段的状态有关，因此我们在考虑状态时，可以减少阶段这个维度，直接将其压缩为单个变量。举例来说，对于n阶段动态规划求最优解，states[i]表示第i步（阶段属性）时的最优解（价值属性），且有：
```golang
for i:=1;i<length;i++ {
	states[i] = f(states[i-1])  // 当前阶段的最优解，为上一阶段最优解的函数
}
return states[length-1]			// 整个问题的最优解为最后一个阶段的最优解
```
我们可以将阶段属性这个维度直接压缩为一个变量state：
```golang
for i:=1;i<length;i++ {
	state := f(state)
}
return state
```
有时候，如果当前多个状态的取值都依赖于上一次的同一状态，那么可以定义变量临时存放新的状态值，待利用完上一次的状态值后，再用这些临时变量赋值替换当前状态的取值。比如：
```golang
for i:=1;i<length;i++ {
    	stateNew1 := func1(state1, state2)  // state1和state2的取值计算都依赖于先前值，故定义临时变量保存
    	stateNew2 := func2(state1, state2)

	state1,state2 = stateNew1,stateNew2
}
return funcN(state1, state2)
```

我们之所以尝试合并属性减少数组维度，是因为多维数组存在如下固有的弊端：
1. 属性的语义不明确。对states[i][2][2]而言，每个属性用数组的一个维度表示，每个属性的每个状态也是用一个数字表示，比如states[i][1][0],表示第i阶段，当天持有股票，且没有卖出股票这个状态所对应的最大收益。在推导过程中，我们要始终要在大脑中建立数字和属性状态的映射，才能进行状态转移方程的推导。
2. 属性或者说数组维度越多，需要考虑的状态越多，推导就越复杂：首先是当前的状态数量多，其次是达到当前状态的可能性也越多。

提前缩减合并属性，减少状态数组的维度，相当于**分阶段提前简化逻辑**，降低了后续推导状态转移方程的难度。

进一步的，当某个维度的长度比较小时，我们往往将多维数组拆分为多个一维数组，并赋予其明确的语义。
1. 一个[n][m]数组可以拆分为m个[n]数组，如果`m<=5`
2. 通过为每个数组起一个适当的名字，赋予其明确的语义。

比如本题解将当前是否持有股票，以及是否卖出过股票分解成三个数组
1. hold[i]表示第i天持有股票时
2. unhold0[i]表示第i天不持有股票，且第i天没有卖出过股票
3. unhold1[i]表示不持有股票，且第i天卖出过股票

这样在推导状态转移方程时，就比较方便了。

进一步的状态压缩优化，就是将表示多阶段的数组压缩为一个变量。如果迭代时当前阶段的值只与上一阶段有关，那么我们总可以这样来做。你可以尝试优化下述代码。


## 代码
```golang
func maxProfit(prices []int) int {
	length := len(prices)
	if length == 0 || length == 1 {
		return 0
	}

	hold := make([]int, length)    // 第i天持有股票
	unhold0 := make([]int, length) // 第i天不持有股票，且第i天没有卖出过股票
	unhold1 := make([]int, length) // 第i天不持有股票，且第i天卖出过股票

	hold[0] = -prices[0] // 第一天买入股票
	unhold0[0] = 0       // 第一天没有买
	unhold1[0] = 0       // 第一天买入随即卖出
	for i := 1; i < length; i++ {
		hold[i] = max(hold[i-1], unhold0[i-1]-prices[i])
		unhold0[i] = max(unhold0[i-1], unhold1[i-1])
		unhold1[i] = hold[i-1] + prices[i]

	}

	return max(unhold0[length-1], unhold1[length-1])
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
```
