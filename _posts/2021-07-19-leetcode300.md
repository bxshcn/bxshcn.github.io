---
layout: post
title:  "最长上升子序列"
comments: true
categories: 算法
---

## 动态规划
为方便进行动态规划的推导，一般可以定义一个数组`dp []int`，其中下标i对应元素下标，其值为以i结尾的最长上升子序列的**长度**，因为待求的解就是对长度的考量。则问题的关键是`dp[i]`与先前已知的`dp[j], j in (0...i-1)`是什么关系？

很多情况下，`dp[i]`只与其前一个元素`dp[i-1]`有关，也许我们已经习惯了利用有限个已知的状态值来推导当前状态值，但也有很多时候，我们必须利用**所有已知的状态值**来推导当前状态值。

分析的过程其实比较直接，我们可以找一个例子，画出对应的`nums[i]`和`dp[i]`：

我们要求解`dp[i]`，意味着我们要将当前数`nums[i]`放到一个已知序列的尾部，并且保证`nums[i] > nums[j]，其中j<i`，注意，`dp[j]`实际上就对应一个序列，虽然我们没有保存这个序列，而只是保存了这个序列（也即最长子序列）对应的长度，但我们的确应该了解到，`dp[j]`对应了一个序列。

所以问题其实就比较明朗了，我们要在`nums[0]...nums[i-1]`中寻找满足条件`nums[i] > nums[j]`的所有元素，然后针对这些元素的`dp[j]`，找出其中的最大者假设为max，我们把nums[i]追加在这个序列的后面，得到一个最长的子序列，其长度dp[i]等于max+1。注意每个`dp[j]`都对应一个以`nums[j]`结尾的最长子序列。

核心代码大略为：
```Go
	// for i
		max := 0
		for j := 0; j < i; j++ { // 求num[j]<nums[i]所对应所有j的lis[j]的最大值
			if nums[i] > nums[j] && dp[j] > max {
				max = dp[j]
			}
		}
		dp[i] = max + 1
```


## 贪心+二分法
这个思路的核心是贪心，二分法只是实现相关思路的一种手段，我们当然也可以采用暴力手段（比如循环遍历O(n)的复杂度）来支持贪心求解。

如果我们要使上升子序列尽可能的长，那么就要使上升的速度尽可能的慢。这句话的意思实际上就是，当上升子序列的长度相同时，子序列的最后一个元素要尽可能的小。这就是我们要抽象的一个属性，即元素的值。

所以我们设计一个数组`d[i]`,其中`i`表示最长子序列的长度，`d[i]`表示所有长度为i的子序列的尾元素中的最小者。那么`d[j]`是一个递增的数组。:


那么对于新加入的元素`nums[i]`，我们只要将与所有`d[j]`进行比较：
1. 如果`nums[i]`大于所有`d[j]`，意味着我们得到一个长度增1的新的子序列，其最后一个元素为nums[i]，即`d[len++]=nums[i]`
2. 如果`nums[i]`小于所有`d[j]`, 意味着我们要更新d[1]的值为nums[i]
3. 否则，我们找到`d[j-1]<nums[i]<d[j]`，然后更新`d[j]=nums[i]`

这个查找的过程既可以遍历，也可以二分查找，因为d[j]是一个递增数组。

## 进一步分析
显然，动态规划的方法更好理解，贪心方法的难点在于数组的设计。但在这两种情况下，我们都跟踪到了**最长子序列的尾元素**，虽然两种情况下，这个最长子序列的含义有区别：
1. 动态规划。最长子序列表示以nums[i]结尾的最长子序列，但题目求解的是整个数组的最长子序列
2. 贪心。最长子序列表示长度为i，并以d[i]结尾的最长子序列。

根据这两个数组的语义，我们不难得到最终的解。但为什么尾元素如此重要呢？显然，只有尾元素的大小才能决定了新考察的元素`nums[i]`是否会增加序列的长度：只有掌握了先前有效子序列的尾元素，一切推导才有意义。

另外一个纳入跟踪的就是子序列的长度：
1. 动态规划。这个思路下，子序列的长度作为跟踪数组`dp[i]`的值体现。
2. 贪心。子序列的长度作为数组的下标存在。

所以无论思路如何，关键的考察属性都要纳入到**分阶段求解**的**状态**表示中，状态是澄清思路的一把钥匙。